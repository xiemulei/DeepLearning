# 配置 (Config)

在编写科学代码时，您通常有很多需要设置的值，深度学习也不例外。Python 有可能为函数定义默认参数，这有助于改善开发者体验。然而，这有一个缺点，即在升级到新版本时可能会破坏您的代码，因为默认值可能在您不知情的情况下发生变化，使得调试非常具有挑战性。

考虑到这一点，我们设计了 Config 系统。它是一个简单的 Rust derive，您可以应用于您的类型，允许您轻松定义默认值。此外，所有配置都可以序列化，减少了升级版本时的潜在错误并提高了可重现性。

```rust
use burn::config::Config;

#[derive(Config)]
pub struct MyModuleConfig {
    d_model: usize,
    d_ff: usize,
    #[config(default = 0.1)]
    dropout: f64,
}
```

该 derive 还为配置的每个属性添加了有用的 `with_` 方法，类似于构建器模式，以及一个 `save` 方法。

```rust
fn main() {
    let config = MyModuleConfig::new(512, 2048);
    println!("{}", config.d_model); // 512
    println!("{}", config.d_ff); // 2048
    println!("{}", config.dropout); // 0.1
    let config =  config.with_dropout(0.2);
    println!("{}", config.dropout); // 0.2

    config.save("config.json").unwrap();
}
```

## 最佳实践 (Good practices)

通过使用配置类型，很容易创建新的模块实例。初始化方法应该在配置类型上实现，以设备作为参数。

```rust
impl MyModuleConfig {
    /// 在给定设备上创建模块。
    pub fn init<B: Backend>(&self, device: &B::Device) -> MyModule {
        MyModule {
            linear: LinearConfig::new(self.d_model, self.d_ff).init(device),
            dropout: DropoutConfig::new(self.dropout).init(),
        }
    }
}
```

然后我们可以在上面的 `main` 函数中添加这行代码：

```rust
use burn::backend::Wgpu;
let device = Default::default();
let my_module = config.init::<Wgpu>(&device);
```

---

*本文档翻译自 Burn 官方文档：https://burn.dev/books/burn/building-blocks/config.html*
