# 保存和加载模型 (Saving and Loading Models)

保存您训练的机器学习模型非常简单，无论您选择哪种输出格式。如 <a href="./building-blocks/record.html">记录</a> 部分所述，支持不同的格式来序列化/反序列化模型。默认情况下，我们使用 `NamedMpkFileRecorder`，它借助 <a href="https://docs.rs/rmp-serde/">rmp_serde</a> 使用 <a href="https://msgpack.org/">MessagePack</a> 二进制序列化格式。

```rust
// 以全精度保存模型为 MessagePack 格式
let recorder = NamedMpkFileRecorder::<FullPrecisionSettings>::new();
model
    .save_file(model_path, &recorder)
    .expect("应该能够保存模型");
```

请注意，文件扩展名由记录器根据您选择的格式自动处理。因此，只需提供文件路径和基本名称。

现在您已将训练好的模型保存到磁盘，可以以类似的方式轻松加载它。

```rust
// 从 MessagePack 文件以全精度加载模型
let recorder = NamedMpkFileRecorder::<FullPrecisionSettings>::new();
model = model
    .load_file(model_path, &recorder, device)
    .expect("应该能够从提供的文件加载模型权重");
```

**注意：** 模型可以以不同的输出格式保存，只需确保在加载保存的模型时使用正确的记录器类型。不同精度设置之间的类型转换会自动处理，但格式不可互换。模型可以从一种格式加载并保存为另一种格式，只要之后使用新的记录器类型加载回来即可。

## 从记录的权重初始化 (Initialization from Recorded Weights)

为模块加载权重的最直接方法是使用生成的 <a href="https://burn.dev/docs/burn/module/trait.Module.html#tymethod.load_record">load_record</a> 方法。请注意，参数初始化是惰性的，因此在模块被使用之前不会执行实际的张量分配和 GPU/CPU 内核。这意味着您可以使用 `init(device)` 后跟 `load_record(record)` 而没有任何有意义的性能成本。

```rust
// 创建一个虚拟初始化的模型来保存
let device = Default::default();
let model = Model::<MyBackend>::init(&device);

// 以全精度保存模型为 MessagePack 格式
let recorder = NamedMpkFileRecorder::<FullPrecisionSettings>::new();
model
    .save_file(model_path, &recorder)
    .expect("应该能够保存模型");
```

之后，模型可以同样轻松地从保存在磁盘上的记录加载。

```rust
// 在后端的默认设备上加载模型记录
let record: ModelRecord<MyBackend> = NamedMpkFileRecorder::<FullPrecisionSettings>::new()
    .load(model_path.into(), &device)
    .expect("应该能够从提供的文件加载模型权重");

// 使用加载的记录/权重初始化新模型
let model = Model::init(&device).load_record(record);
```

## 无存储，没问题！(No Storage, No Problem!)

对于运行时可能无法（或不希望）使用文件存储的应用程序，您可以使用 `BinBytesRecorder`。

在之前的示例中，我们使用了基于 MessagePack 格式的 `FileRecorder`，它可以替换为您选择的 <a href="./building-blocks/record.html#recorder">另一个文件记录器</a>。要将模型嵌入为运行时应用程序的一部分，首先使用 `BinFileRecorder` 将模型保存到二进制文件。

```rust
// 以全精度保存模型为二进制格式
let recorder = BinFileRecorder::<FullPrecisionSettings>::new();
model
    .save_file(model_path, &recorder)
    .expect("应该能够保存模型");
```

然后，在您的最终应用程序中，包含模型并使用 `BinBytesRecorder` 加载它。

将模型嵌入为应用程序的一部分对于较小的模型特别有用，但对于非常大的模型不推荐，因为它会显著增加二进制大小并在运行时消耗更多内存。

```rust
// 将模型文件作为字节数组的引用包含
static MODEL_BYTES: &[u8] = include_bytes!("path/to/model.bin");

// 以全精度加载模型二进制记录
let record = BinBytesRecorder::<FullPrecisionSettings>::default()
    .load(MODEL_BYTES.to_vec(), device)
    .expect("应该能够从字节加载模型模型权重");

// 使用模型加载该记录
model.load_record(record);
```

此示例假设在加载模型记录之前模型已经创建。如果您想跳过随机初始化并直接使用提供的记录初始化权重，您可以像 <a href="#initialization-from-recorded-weights">之前的示例</a> 那样调整它。

---

*本文档翻译自 Burn 官方文档：https://burn.dev/books/burn/saving-and-loading.html*
