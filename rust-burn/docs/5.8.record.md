# 记录 (Record)

记录是 Burn 保存状态的方式。与大多数其他框架相比，Burn 拥有自己的高级保存机制，允许后端之间的互操作性，并尽可能减少运行时错误。Burn 决定创建自己的保存格式有多个原因。

首先，Rust 有 [serde](https://serde.rs/)，这是一个极其完善的序列化和反序列化库，也为 Hugging Face 开发的 `safetensors` 格式提供支持。如果正确使用，所有验证都在反序列化时完成，这消除了编写验证代码的需要。由于 Burn 中的模块是用配置创建的，它们无法实现序列化和反序列化。这就是创建记录系统的原因：允许您独立于后端保存模块状态，速度极快，同时仍然给您所有可能的灵活性，以在模块中包含任何不可序列化的字段。

## 为什么不使用 safetensors？

[safetensors](https://github.com/huggingface/safetensors) 使用 serde 和 JSON 文件格式，并且只支持序列化和反序列化张量。Burn 中的记录系统使您能够序列化任何类型，这对于保存其状态的优化器非常有用，但对于您可能拥有的任何非标准、前沿建模需求也是如此。此外，记录系统通过使用 Rust 类型执行自动精度转换，使其更可靠，减少了手动操作。

需要注意的是，`safetensors` 格式使用 "safe" 这个词来区别于容易受到 Python 代码注入攻击的 Pickle。在我们这边，我们使用 Rust 这一简单事实已经确保不可能发生代码注入。如果您的存储机制不处理数据损坏，您可能更喜欢执行校验和验证的记录器（即任何带有 Gzip 压缩的记录器）。

## 记录器 (Recorder)

记录器独立于后端，并以精度和格式序列化记录。请注意，格式也可以在内存中，允许您将记录直接保存到字节中。

| 记录器 | 格式 | 压缩 |
|---------|------|------|
| DefaultFileRecorder | 文件 - 命名 MessagePack | 无 |
| NamedMpkFileRecorder | 文件 - 命名 MessagePack | 无 |
| NamedMpkGzFileRecorder | 文件 - 命名 MessagePack | Gzip |
| BinFileRecorder | 文件 - 二进制 | 无 |
| BinGzFileRecorder | 文件 - 二进制 | Gzip |
| JsonGzFileRecorder | 文件 - Json | Gzip |
| PrettyJsonFileRecorder | 文件 - 美化 Json | Gzip |
| BinBytesRecorder | 内存 - 二进制 | 无 |

每个记录器都支持与用于训练或推理的精度解耦的精度设置。这些设置允许您定义将用于序列化和反序列化的浮点和整数类型。

| 设置 | 浮点精度 | 整数精度 |
|------|----------|----------|
| `DoublePrecisionSettings` | `f64` | `i64` |
| `FullPrecisionSettings` | `f32` | `i32` |
| `HalfPrecisionSettings` | `f16` | `i16` |

请注意，当将记录加载到模块中时，类型转换会自动处理，因此您不会遇到错误。唯一关键的方面是对序列化和反序列化使用相同的记录器；否则，您会遇到加载错误。

## 应该使用哪种记录器？

- 如果您想要快速的序列化和反序列化，请选择不压缩的记录器。没有压缩时文件大小最小的是二进制格式；否则，可以使用命名 MessagePack。
- 如果您想要保存模型用于存储，可以使用压缩，但避免使用二进制格式，因为它可能不向后兼容。
- 如果您想要调试模型权重，可以使用美化 JSON 格式。
- 如果您想要使用 `no-std` 部署，请使用内存二进制格式，并将字节包含在编译代码中。

有关保存和加载记录的示例，请查看[保存和加载模型](../saving-and-loading.html)。

---

*本文档翻译自 Burn 官方文档：https://burn.dev/books/burn/building-blocks/record.html*
