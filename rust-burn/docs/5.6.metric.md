# 指标 (Metric)

在使用学习器时，您可以选择记录将在整个训练过程中监控的指标。我们目前提供有限范围的指标。

| 指标 | 描述 |
|------|------|
| Accuracy | 以百分比计算准确率 |
| TopKAccuracy | 以百分比计算 top-k 准确率 |
| Precision | 以百分比计算精确率 |
| Recall | 以百分比计算召回率 |
| FBetaScore | 以百分比计算 F<sub>β</sub> 分数 |
| AUROC | 以百分比计算 ROC 曲线下面积 |
| Loss | 输出用于反向传播的损失 |
| CPU Temperature | 获取 CPU 温度 |
| CPU Usage | 获取 CPU 利用率 |
| CPU Memory Usage | 获取 CPU RAM 使用量 |
| GPU Temperature | 获取 GPU 温度 |
| Learning Rate | 获取每个优化器步骤的当前学习率 |
| CUDA | 获取通用 CUDA 指标，如利用率 |

为了使用指标，您的训练步骤输出必须实现来自 `burn-train::metric` 的 `Adaptor` trait。以下是分类输出的示例，该示例已随 crate 提供。

```rust
/// 适用于多个指标的简单分类输出。
#[derive(new)]
pub struct ClassificationOutput<B: Backend> {
    /// 损失。
    pub loss: Tensor<B, 1>,

    /// 输出。
    pub output: Tensor<B, 2>,

    /// 目标。
    pub targets: Tensor<B, 1, Int>,
}

impl<B: Backend> Adaptor<AccuracyInput<B>> for ClassificationOutput<B> {
    fn adapt(&self) -> AccuracyInput<B> {
        AccuracyInput::new(self.output.clone(), self.targets.clone())
    }
}

impl<B: Backend> Adaptor<LossInput<B>> for ClassificationOutput<B> {
    fn adapt(&self) -> LossInput<B> {
        LossInput::new(self.loss.clone())
    }
}
```

# 自定义指标 (Custom Metric)

通过实现 `Metric` trait 来生成您自己的自定义指标。

```rust
/// 指标 trait。
///
/// # 注意事项
///
/// 实现应该定义仅由指标使用的自己的输入类型。
/// 这很重要，因为当模型输出为每个指标的输入类型进行适配时可能会发生一些冲突。
pub trait Metric: Send + Sync {
    /// 指标的输入类型。
    type Input;

    /// 指标的参数化名称。
    ///
    /// 这应该是唯一的，所以避免使用简短的通用名称，优先使用长名称。
    ///
    /// 对于可以存在于不同参数的指标（例如，不同 k 值的 top-k 准确率），
    /// 名称对于每个实例应该是唯一的。
    fn name(&self) -> String;

    /// 更新指标状态并返回当前指标条目。
    fn update(&mut self, item: &Self::Input, metadata: &MetricMetadata) -> MetricEntry;
    /// 清除指标状态。
    fn clear(&mut self);
}
```

作为示例，让我们看看损失指标是如何实现的。

```rust
/// 损失指标。
#[derive(Default)]
pub struct LossMetric<B: Backend> {
    state: NumericMetricState,
    _b: B,
}

/// 损失指标输入类型。
#[derive(new)]
pub struct LossInput<B: Backend> {
    tensor: Tensor<B, 1>,
}

impl<B: Backend> Metric for LossMetric<B> {
    type Input = LossInput<B>;

    fn update(&mut self, loss: &Self::Input, _metadata: &MetricMetadata) -> MetricEntry {
        let [batch_size] = loss.tensor.dims();
        let loss = loss
            .tensor
            .clone()
            .mean()
            .into_data()
            .iter::<f64>()
            .next()
            .unwrap();

        self.state.update(
            loss,
            batch_size,
            FormatOptions::new(self.name()).precision(2),
        )
    }

    fn clear(&mut self) {
        self.state.reset()
    }

    fn name(&self) -> String {
        "Loss".to_string()
    }
}
```

当您实现的指标本质上是数值型时，您可能还想实现 `Numeric` trait。这将允许您的指标被绘制。

```rust
impl<B: Backend> Numeric for LossMetric<B> {
    fn value(&self) -> f64 {
        self.state.value()
    }
}
```

---

*本文档翻译自 Burn 官方文档：https://burn.dev/books/burn/building-blocks/metric.html*
